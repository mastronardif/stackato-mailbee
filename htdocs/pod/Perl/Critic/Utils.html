<html><head><title>Perl::Critic::Utils</title>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1" >
<link rel="stylesheet" title="blkbluw" type="text/css" href="../../_blkbluw.css" media="all" >
<link rel="alternate stylesheet" title="blkmagw" type="text/css" href="../../_blkmagw.css" media="all" >
<link rel="alternate stylesheet" title="blkcynw" type="text/css" href="../../_blkcynw.css" media="all" >
<link rel="alternate stylesheet" title="whtprpk" type="text/css" href="../../_whtprpk.css" media="all" >
<link rel="alternate stylesheet" title="whtnavk" type="text/css" href="../../_whtnavk.css" media="all" >
<link rel="alternate stylesheet" title="grygrnk" type="text/css" href="../../_grygrnk.css" media="all" >
<link rel="alternate stylesheet" title="whtgrng" type="text/css" href="../../_whtgrng.css" media="all" >
<link rel="alternate stylesheet" title="blkgrng" type="text/css" href="../../_blkgrng.css" media="all" >
<link rel="alternate stylesheet" title="grygrnw" type="text/css" href="../../_grygrnw.css" media="all" >
<link rel="alternate stylesheet" title="blkbluw" type="text/css" href="../../_blkbluw.css" media="all" >
<link rel="alternate stylesheet" title="whtpurk" type="text/css" href="../../_whtpurk.css" media="all" >
<link rel="alternate stylesheet" title="whtgrng" type="text/css" href="../../_whtgrng.css" media="all" >
<link rel="alternate stylesheet" title="grygrnw" type="text/css" href="../../_grygrnw.css" media="all" >

<script type="text/javascript" src="../../_podly.js"></script>

</head>
<body class='pod'>
<!--
  generated by Pod::Simple::HTML v3.16,
  using Pod::Simple::PullParser v3.16,
  under Perl v5.012001 at Wed Apr 13 00:04:30 2011 GMT.

 If you want to change this HTML document, you probably shouldn't do that
   by changing it directly.  Instead, see about changing the calling options
   to Pod::Simple::HTML, and/or subclassing Pod::Simple::HTML,
   then reconverting this document from the Pod source.
   When in doubt, email the author of Pod::Simple::HTML for advice.
   See 'perldoc Pod::Simple::HTML' for more info.

-->

<!-- start doc -->
<p class="backlinktop"><b><a name="___top" href="../../index.html" accesskey="1" title="All Documents">&lt;&lt;</a></b></p>

<div class='indexgroup'>
<ul   class='indexList indexList1'>
  <li class='indexItem indexItem1'><a href='#NAME'>NAME</a>
  <li class='indexItem indexItem1'><a href='#DESCRIPTION'>DESCRIPTION</a>
  <li class='indexItem indexItem1'><a href='#INTERFACE_SUPPORT'>INTERFACE SUPPORT</a>
  <li class='indexItem indexItem1'><a href='#IMPORTABLE_SUBS'>IMPORTABLE SUBS</a>
  <li class='indexItem indexItem1'><a href='#IMPORTABLE_VARIABLES'>IMPORTABLE VARIABLES</a>
  <li class='indexItem indexItem1'><a href='#IMPORT_TAGS'>IMPORT TAGS</a>
  <li class='indexItem indexItem1'><a href='#SEE_ALSO'>SEE ALSO</a>
  <li class='indexItem indexItem1'><a href='#AUTHOR'>AUTHOR</a>
  <li class='indexItem indexItem1'><a href='#COPYRIGHT'>COPYRIGHT</a>
</ul>
</div>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="NAME"
>NAME</a></h1>

<p>Perl::Critic::Utils - General utility subroutines and constants for Perl::Critic and derivative distributions.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="DESCRIPTION"
>DESCRIPTION</a></h1>

<p>This module provides several static subs and variables that are useful for developing <a href="../../Perl/Critic/Policy.html" class="podlinkpod"
>Perl::Critic::Policy</a> subclasses.
Unless you are writing Policy modules,
you probably don&#39;t care about this package.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="INTERFACE_SUPPORT"
>INTERFACE SUPPORT</a></h1>

<p>This is considered to be a public module.
Any changes to its interface will go through a deprecation cycle.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="IMPORTABLE_SUBS"
>IMPORTABLE SUBS</a></h1>

<dl>
<dt><a name="find_keywords(_$doc,_$keyword_)"
><code>find_keywords( $doc,
$keyword )</code></a></dt>

<dd>
<p><b>DEPRECATED:</b> Since version 0.11,
every Policy is evaluated at each element of the document.
So you shouldn&#39;t need to go looking for a particular keyword.
If you <i>do</i> want to use this,
please import it via the <code>:deprecated</code> tag,
rather than directly,
to mark the module as needing updating.</p>

<p>Given a <a href="../../PPI/Document.html" class="podlinkpod"
>PPI::Document</a> as <code>$doc</code>,
returns a reference to an array containing all the <a href="../../PPI/Token/Word.html" class="podlinkpod"
>PPI::Token::Word</a> elements that match <code>$keyword</code>.
This can be used to find any built-in function,
method call,
bareword,
or reserved keyword.
It will not match variables,
subroutine names,
literal strings,
numbers,
or symbols.
If the document doesn&#39;t contain any matches,
returns undef.</p>

<dt><a name="is_perl_global(_$element_)"
><code>is_perl_global( $element )</code></a></dt>

<dd>
<p>Given a <a href="../../PPI/Token/Symbol.html" class="podlinkpod"
>PPI::Token::Symbol</a> or a string,
returns true if that token represents one of the global variables provided by the <a href="../../English.html" class="podlinkpod"
>English</a> module,
or one of the builtin global variables like <code>%SIG</code>,
<code>%ENV</code>,
or <code>@ARGV</code>.
The sigil on the symbol is ignored,
so things like <code>$ARGV</code> or <code>$ENV</code> will still return true.</p>

<dt><a name="is_perl_builtin(_$element_)"
><code>is_perl_builtin( $element )</code></a></dt>

<dd>
<p>Given a <a href="../../PPI/Token/Word.html" class="podlinkpod"
>PPI::Token::Word</a>,
<a href="../../PPI/Statement/Sub.html" class="podlinkpod"
>PPI::Statement::Sub</a>,
or string,
returns true if that token represents a call to any of the builtin functions defined in Perl 5.8.8.</p>

<dt><a name="is_perl_bareword(_$element_)"
><code>is_perl_bareword( $element )</code></a></dt>

<dd>
<p>Given a <a href="../../PPI/Token/Word.html" class="podlinkpod"
>PPI::Token::Word</a>,
<a href="../../PPI/Statement/Sub.html" class="podlinkpod"
>PPI::Statement::Sub</a>,
or string,
returns true if that token represents a bareword (e.g.
&#34;if&#34;,
&#34;else&#34;,
&#34;sub&#34;,
&#34;package&#34;) defined in Perl 5.8.8.</p>

<dt><a name="is_perl_filehandle(_$element_)"
><code>is_perl_filehandle( $element )</code></a></dt>

<dd>
<p>Given a <a href="../../PPI/Token/Word.html" class="podlinkpod"
>PPI::Token::Word</a>,
or string,
returns true if that token represents one of the global filehandles (e.g.
<code>STDIN</code>,
<code>STDERR</code>,
<code>STDOUT</code>,
<code>ARGV</code>) that are defined in Perl 5.8.8.
Note that this function will return false if given a filehandle that is represented as a typeglob (e.g.
<code>*STDIN</code>)</p>

<dt><a name="is_perl_builtin_with_list_context(_$element_)"
><code>is_perl_builtin_with_list_context( $element )</code></a></dt>

<dd>
<p>Given a <a href="../../PPI/Token/Word.html" class="podlinkpod"
>PPI::Token::Word</a>,
<a href="../../PPI/Statement/Sub.html" class="podlinkpod"
>PPI::Statement::Sub</a>,
or string,
returns true if that token represents a call to any of the builtin functions defined in Perl 5.8.8 that provide a list context to the following tokens.</p>

<dt><a name="is_perl_builtin_with_multiple_arguments(_$element_)"
><code>is_perl_builtin_with_multiple_arguments( $element )</code></a></dt>

<dd>
<p>Given a <a href="../../PPI/Token/Word.html" class="podlinkpod"
>PPI::Token::Word</a>,
<a href="../../PPI/Statement/Sub.html" class="podlinkpod"
>PPI::Statement::Sub</a>,
or string,
returns true if that token represents a call to any of the builtin functions defined in Perl 5.8.8 that <b>can</b> take multiple arguments.</p>

<dt><a name="is_perl_builtin_with_no_arguments(_$element_)"
><code>is_perl_builtin_with_no_arguments( $element )</code></a></dt>

<dd>
<p>Given a <a href="../../PPI/Token/Word.html" class="podlinkpod"
>PPI::Token::Word</a>,
<a href="../../PPI/Statement/Sub.html" class="podlinkpod"
>PPI::Statement::Sub</a>,
or string,
returns true if that token represents a call to any of the builtin functions defined in Perl 5.8.8 that <b>cannot</b> take any arguments.</p>

<dt><a name="is_perl_builtin_with_one_argument(_$element_)"
><code>is_perl_builtin_with_one_argument( $element )</code></a></dt>

<dd>
<p>Given a <a href="../../PPI/Token/Word.html" class="podlinkpod"
>PPI::Token::Word</a>,
<a href="../../PPI/Statement/Sub.html" class="podlinkpod"
>PPI::Statement::Sub</a>,
or string,
returns true if that token represents a call to any of the builtin functions defined in Perl 5.8.8 that takes <b>one and only one</b> argument.</p>

<dt><a name="is_perl_builtin_with_optional_argument(_$element_)"
><code>is_perl_builtin_with_optional_argument( $element )</code></a></dt>

<dd>
<p>Given a <a href="../../PPI/Token/Word.html" class="podlinkpod"
>PPI::Token::Word</a>,
<a href="../../PPI/Statement/Sub.html" class="podlinkpod"
>PPI::Statement::Sub</a>,
or string,
returns true if that token represents a call to any of the builtin functions defined in Perl 5.8.8 that takes <b>no more than one</b> argument.</p>

<p>The sets of values for which <code>is_perl_builtin_with_multiple_arguments()</code>,
<code>is_perl_builtin_with_no_arguments()</code>,
<code>is_perl_builtin_with_one_argument()</code>,
and <code>is_perl_builtin_with_optional_argument()</code> return true are disjoint and their union is precisely the set of values that <code>is_perl_builtin()</code> will return true for.</p>

<dt><a name="is_perl_builtin_with_zero_and_or_one_arguments(_$element_)"
><code>is_perl_builtin_with_zero_and_or_one_arguments( $element )</code></a></dt>

<dd>
<p>Given a <a href="../../PPI/Token/Word.html" class="podlinkpod"
>PPI::Token::Word</a>,
<a href="../../PPI/Statement/Sub.html" class="podlinkpod"
>PPI::Statement::Sub</a>,
or string,
returns true if that token represents a call to any of the builtin functions defined in Perl 5.8.8 that takes no and/or one argument.</p>

<p>Returns true if any of <code>is_perl_builtin_with_no_arguments()</code>,
<code>is_perl_builtin_with_one_argument()</code>,
and <code>is_perl_builtin_with_optional_argument()</code> returns true.</p>

<dt><a name="is_qualified_name(_$name_)"
><code>is_qualified_name( $name )</code></a></dt>

<dd>
<p>Given a string,
<a href="../../PPI/Token/Word.html" class="podlinkpod"
>PPI::Token::Word</a>,
or <a href="../../PPI/Token/Symbol.html" class="podlinkpod"
>PPI::Token::Symbol</a>,
answers whether it has a module component,
i.e.
contains &#34;::&#34;.</p>

<dt><a name="precedence_of(_$element_)"
><code>precedence_of( $element )</code></a></dt>

<dd>
<p>Given a <a href="../../PPI/Token/Operator.html" class="podlinkpod"
>PPI::Token::Operator</a> or a string,
returns the precedence of the operator,
where 1 is the highest precedence.
Returns undef if the precedence can&#39;t be determined (which is usually because it is not an operator).</p>

<dt><a name="is_hash_key(_$element_)"
><code>is_hash_key( $element )</code></a></dt>

<dd>
<p>Given a <a href="../../PPI/Element.html" class="podlinkpod"
>PPI::Element</a>,
returns true if the element is a literal hash key.
PPI doesn&#39;t distinguish between regular barewords (like keywords or subroutine calls) and barewords in hash subscripts (which are considered literal).
So this subroutine is useful if your Policy is searching for <a href="../../PPI/Token/Word.html" class="podlinkpod"
>PPI::Token::Word</a> elements and you want to filter out the hash subscript variety.
In both of the following examples,
&#34;foo&#34; is considered a hash key:</p>

<pre>    $hash1{foo} = 1;
    %hash2 = (foo =&#62; 1);</pre>

<p>But if the bareword is followed by an argument list, then perl treats it as a function call. So in these examples, &#34;foo&#34; is <b>not</b> considered a hash key:</p>

<pre>    $hash1{ foo() } = 1;
    &#38;hash2 = (foo() =&#62; 1);</pre>

<dt><a name="is_included_module_name(_$element_)"
><code>is_included_module_name( $element )</code></a></dt>

<dd>
<p>Given a <a href="../../PPI/Token/Word.html" class="podlinkpod"
>PPI::Token::Word</a>, returns true if the element is the name of a module that is being included via <code>use</code>, <code>require</code>, or <code>no</code>.</p>

<dt><a name="is_integer(_$value_)"
><code>is_integer( $value )</code></a></dt>

<dd>
<p>Answers whether the parameter, as a string, looks like an integral value.</p>

<dt><a name="is_class_name(_$element_)"
><code>is_class_name( $element )</code></a></dt>

<dd>
<p>Given a <a href="../../PPI/Token/Word.html" class="podlinkpod"
>PPI::Token::Word</a>, returns true if the element that immediately follows this element is the dereference operator &#34;-&#62;&#34;. When a bareword has a &#34;-&#62;&#34; on the <b>right</b> side, it usually means that it is the name of the class (from which a method is being called).</p>

<dt><a name="is_label_pointer(_$element_)"
><code>is_label_pointer( $element )</code></a></dt>

<dd>
<p>Given a <a href="../../PPI/Token/Word.html" class="podlinkpod"
>PPI::Token::Word</a>, returns true if the element is the label in a <code>next</code>, <code>last</code>, <code>redo</code>, or <code>goto</code> statement. Note this is not the same thing as the label declaration.</p>

<dt><a name="is_method_call(_$element_)"
><code>is_method_call( $element )</code></a></dt>

<dd>
<p>Given a <a href="../../PPI/Token/Word.html" class="podlinkpod"
>PPI::Token::Word</a>, returns true if the element that immediately precedes this element is the dereference operator &#34;-&#62;&#34;. When a bareword has a &#34;-&#62;&#34; on the <b>left</b> side, it usually means that it is the name of a method (that is being called from a class).</p>

<dt><a name="is_package_declaration(_$element_)"
><code>is_package_declaration( $element )</code></a></dt>

<dd>
<p>Given a <a href="../../PPI/Token/Word.html" class="podlinkpod"
>PPI::Token::Word</a>, returns true if the element is the name of a package that is being declared.</p>

<dt><a name="is_subroutine_name(_$element_)"
><code>is_subroutine_name( $element )</code></a></dt>

<dd>
<p>Given a <a href="../../PPI/Token/Word.html" class="podlinkpod"
>PPI::Token::Word</a>, returns true if the element is the name of a subroutine declaration. This is useful for distinguishing barewords and from function calls from subroutine declarations.</p>

<dt><a name="is_function_call(_$element_)"
><code>is_function_call( $element )</code></a></dt>

<dd>
<p>Given a <a href="../../PPI/Token/Word.html" class="podlinkpod"
>PPI::Token::Word</a> returns true if the element appears to be call to a static function. Specifically, this function returns true if <code>is_hash_key</code>, <code>is_method_call</code>, <code>is_subroutine_name</code>, <code>is_included_module_name</code>, <code>is_package_declaration</code>, <code>is_perl_bareword</code>, <code>is_perl_filehandle</code>, <code>is_label_pointer</code> and <code>is_subroutine_name</code> all return false for the given element.</p>

<dt><a name="first_arg(_$element_)"
><code>first_arg( $element )</code></a></dt>

<dd>
<p>Given a <a href="../../PPI/Element.html" class="podlinkpod"
>PPI::Element</a> that is presumed to be a function call (which is usually a <a href="../../PPI/Token/Word.html" class="podlinkpod"
>PPI::Token::Word</a>), return the first argument. This is similar of <code>parse_arg_list()</code> and follows the same logic. Note that for the code:</p>

<pre>    int($x + 0.5)</pre>

<p>this function will return just the <code>$x</code>, not the whole expression. This is different from the behavior of <code>parse_arg_list()</code>. Another caveat is:</p>

<pre>    int(($x + $y) + 0.5)</pre>

<p>which returns <code>($x + $y)</code> as a <a href="../../PPI/Structure/List.html" class="podlinkpod"
>PPI::Structure::List</a> instance.</p>

<dt><a name="parse_arg_list(_$element_)"
><code>parse_arg_list( $element )</code></a></dt>

<dd>
<p>Given a <a href="../../PPI/Element.html" class="podlinkpod"
>PPI::Element</a> that is presumed to be a function call (which is usually a <a href="../../PPI/Token/Word.html" class="podlinkpod"
>PPI::Token::Word</a>), splits the argument expressions into arrays of tokens. Returns a list containing references to each of those arrays. This is useful because parentheses are optional when calling a function, and PPI parses them very differently. So this method is a poor-man&#39;s parse tree of PPI nodes. It&#39;s not bullet-proof because it doesn&#39;t respect precedence. In general, I don&#39;t like the way this function works, so don&#39;t count on it to be stable (or even present).</p>

<dt><a name="split_nodes_on_comma(_@nodes_)"
><code>split_nodes_on_comma( @nodes )</code></a></dt>

<dd>
<p>This has the same return type as <code>parse_arg_list()</code> but expects to be passed the nodes that represent the interior of a list, like:</p>

<pre>    &#39;foo&#39;, 1, 2, &#39;bar&#39;</pre>

<dt><a name="is_script(_$document_)"
><code>is_script( $document )</code></a></dt>

<dd>
<p><b>This subroutine is deprecated and will be removed in a future release.</b> You should use the <a href="../../Perl/Critic/Document.html#is_program()" class="podlinkpod"
>&#34;is_program()&#34; in Perl::Critic::Document</a> method instead.</p>

<dt><a name="is_in_void_context(_$token_)"
><code>is_in_void_context( $token )</code></a></dt>

<dd>
<p>Given a <a href="../../PPI/Token.html" class="podlinkpod"
>PPI::Token</a>, answer whether it appears to be in a void context.</p>

<dt><a name="policy_long_name(_$policy_name_)"
><code>policy_long_name( $policy_name )</code></a></dt>

<dd>
<p>Given a policy class name in long or short form, return the long form.</p>

<dt><a name="policy_short_name(_$policy_name_)"
><code>policy_short_name( $policy_name )</code></a></dt>

<dd>
<p>Given a policy class name in long or short form, return the short form.</p>

<dt><a name="all_perl_files(_@directories_)"
><code>all_perl_files( @directories )</code></a></dt>

<dd>
<p>Given a list of directories, recursively searches through all the directories (depth first) and returns a list of paths for all the files that are Perl code files. Any administrative files for CVS or Subversion are skipped, as are things that look like temporary or backup files.</p>

<p>A Perl code file is:</p>

<ul>
<li>Any file that ends in <em>.PL</em>, <em>.pl</em>, <em>.pm</em>, or <em>.t</em></li>

<li>Any file that has a first line with a shebang containing &#39;perl&#39;</li>
</ul>

<dt><a name="severity_to_number(_$severity_)"
><code>severity_to_number( $severity )</code></a></dt>

<dd>
<p>If <code>$severity</code> is given as an integer, this function returns <code>$severity</code> but normalized to lie between <code>$SEVERITY_LOWEST</code> and <code>$SEVERITY_HIGHEST</code>. If <code>$severity</code> is given as a string, this function returns the corresponding severity number. If the string doesn&#39;t have a corresponding number, this function will throw an exception.</p>

<dt><a name="is_valid_numeric_verbosity(_$severity_)"
><code>is_valid_numeric_verbosity( $severity )</code></a></dt>

<dd>
<p>Answers whether the argument has a translation to a Violation format.</p>

<dt><a name="verbosity_to_format(_$verbosity_level_)"
><code>verbosity_to_format( $verbosity_level )</code></a></dt>

<dd>
<p>Given a verbosity level between 1 and 10, returns the corresponding predefined format string. These formats are suitable for passing to the <code>set_format</code> method in <a href="../../Perl/Critic/Violation.html" class="podlinkpod"
>Perl::Critic::Violation</a>. See the <a href="../../perlcritic.html" class="podlinkpod"
>perlcritic</a> documentation for a listing of the predefined formats.</p>

<dt><a name="hashify(_@list_)"
><code>hashify( @list )</code></a></dt>

<dd>
<p>Given <code>@list</code>, return a hash where <code>@list</code> is in the keys and each value is 1. Duplicate values in <code>@list</code> are silently squished.</p>

<dt><a name="interpolate(_$literal_)"
><code>interpolate( $literal )</code></a></dt>

<dd>
<p>Given a <code>$literal</code> string that may contain control characters (e.g.. &#39;\t&#39; &#39;\n&#39;), this function does a double interpolation on the string and returns it as if it had been declared in double quotes. For example:</p>

<pre>    &#39;foo \t bar \n&#39; ...becomes... &#34;foo \t bar \n&#34;</pre>

<dt><a name="shebang_line(_$document_)"
><code>shebang_line( $document )</code></a></dt>

<dd>
<p>Given a <a href="../../PPI/Document.html" class="podlinkpod"
>PPI::Document</a>, test if it starts with <code>#!</code>. If so, return that line. Otherwise return undef.</p>

<dt><a name="words_from_string(_$str_)"
><code>words_from_string( $str )</code></a></dt>

<dd>
<p>Given config string <i>$str</i>, return all the words from the string. This is safer than splitting on whitespace.</p>

<dt><a name="is_unchecked_call(_$element_)"
><code>is_unchecked_call( $element )</code></a></dt>

<dd>
<p>Given a <a href="../../PPI/Element.html" class="podlinkpod"
>PPI::Element</a>, test to see if it contains a function call whose return value is not checked.</p>
</dd>
</dl>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="IMPORTABLE_VARIABLES"
>IMPORTABLE VARIABLES</a></h1>

<dl>
<dt><a name="$COMMA"
><code>$COMMA</code></a></dt>

<dd>
<dt><a name="$FATCOMMA"
><code>$FATCOMMA</code></a></dt>

<dd>
<dt><a name="$COLON"
><code>$COLON</code></a></dt>

<dd>
<dt><a name="$SCOLON"
><code>$SCOLON</code></a></dt>

<dd>
<dt><a name="$QUOTE"
><code>$QUOTE</code></a></dt>

<dd>
<dt><a name="$DQUOTE"
><code>$DQUOTE</code></a></dt>

<dd>
<dt><a name="$BACKTICK"
><code>$BACKTICK</code></a></dt>

<dd>
<dt><a name="$PERIOD"
><code>$PERIOD</code></a></dt>

<dd>
<dt><a name="$PIPE"
><code>$PIPE</code></a></dt>

<dd>
<dt><a name="$EMPTY"
><code>$EMPTY</code></a></dt>

<dd>
<dt><a name="$EQUAL"
><code>$EQUAL</code></a></dt>

<dd>
<dt><a name="$SPACE"
><code>$SPACE</code></a></dt>

<dd>
<dt><a name="$SLASH"
><code>$SLASH</code></a></dt>

<dd>
<dt><a name="$BSLASH"
><code>$BSLASH</code></a></dt>

<dd>
<dt><a name="$LEFT_PAREN"
><code>$LEFT_PAREN</code></a></dt>

<dd>
<dt><a name="$RIGHT_PAREN"
><code>$RIGHT_PAREN</code></a></dt>

<dd>
<p>These character constants give clear names to commonly-used strings that can be hard to read when surrounded by quotes and other punctuation. Can be imported in one go via the <code>:characters</code> tag.</p>

<dt><a name="$SEVERITY_HIGHEST"
><code>$SEVERITY_HIGHEST</code></a></dt>

<dd>
<dt><a name="$SEVERITY_HIGH"
><code>$SEVERITY_HIGH</code></a></dt>

<dd>
<dt><a name="$SEVERITY_MEDIUM"
><code>$SEVERITY_MEDIUM</code></a></dt>

<dd>
<dt><a name="$SEVERITY_LOW"
><code>$SEVERITY_LOW</code></a></dt>

<dd>
<dt><a name="$SEVERITY_LOWEST"
><code>$SEVERITY_LOWEST</code></a></dt>

<dd>
<p>These numeric constants define the relative severity of violating each <a href="../../Perl/Critic/Policy.html" class="podlinkpod"
>Perl::Critic::Policy</a>. The <code>get_severity</code> and <code>default_severity</code> methods of every Policy subclass must return one of these values. Can be imported via the <code>:severities</code> tag.</p>

<dt><a name="$DEFAULT_VERBOSITY"
><code>$DEFAULT_VERBOSITY</code></a></dt>

<dd>
<p>The default numeric verbosity.</p>

<dt><a name="$DEFAULT_VERBOSITY_WITH_FILE_NAME"
><code>$DEFAULT_VERBOSITY_WITH_FILE_NAME</code></a></dt>

<dd>
<p>The numeric verbosity that corresponds to the format indicated by <code>$DEFAULT_VERBOSITY</code>, but with the file name prefixed to it.</p>

<dt><a name="$TRUE"
><code>$TRUE</code></a></dt>

<dd>
<dt><a name="$FALSE"
><code>$FALSE</code></a></dt>

<dd>
<p>These are simple booleans. 1 and 0 respectively. Be mindful of using these with string equality. <code>$FALSE ne $EMPTY</code>. Can be imported via the <code>:booleans</code> tag.</p>
</dd>
</dl>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="IMPORT_TAGS"
>IMPORT TAGS</a></h1>

<p>The following groups of functions and constants are available as parameters to a <code>use Perl::Critic::Util</code> statement.</p>

<dl>
<dt><a name=":all"
><code>:all</code></a></dt>

<dd>
<p>The lot.</p>

<dt><a name=":booleans"
><code>:booleans</code></a></dt>

<dd>
<p>Includes: <code>$TRUE</code>, <code>$FALSE</code></p>

<dt><a name=":severities"
><code>:severities</code></a></dt>

<dd>
<p>Includes: <code>$SEVERITY_HIGHEST</code>, <code>$SEVERITY_HIGH</code>, <code>$SEVERITY_MEDIUM</code>, <code>$SEVERITY_LOW</code>, <code>$SEVERITY_LOWEST</code>, <code>@SEVERITY_NAMES</code></p>

<dt><a name=":characters"
><code>:characters</code></a></dt>

<dd>
<p>Includes: <code>$COLON</code>, <code>$COMMA</code>, <code>$DQUOTE</code>, <code>$EMPTY</code>, <code>$FATCOMMA</code>, <code>$PERIOD</code>, <code>$PIPE</code>, <code>$QUOTE</code>, <code>$BACKTICK</code>, <code>$SCOLON</code>, <code>$SPACE</code>, <code>$SLASH</code>, <code>$BSLASH</code> <code>$LEFT_PAREN</code> <code>$RIGHT_PAREN</code></p>

<dt><a name=":classification"
><code>:classification</code></a></dt>

<dd>
<p>Includes: <code>is_function_call</code>, <code>is_hash_key</code>, <code>is_included_module_name</code>, <code>is_integer</code>, <code>is_method_call</code>, <code>is_package_declaration</code>, <code>is_perl_builtin</code>, <code>is_perl_global</code>, <code>is_perl_builtin_with_list_context</code> <code>is_perl_builtin_with_multiple_arguments</code> <code>is_perl_builtin_with_no_arguments</code> <code>is_perl_builtin_with_one_argument</code> <code>is_perl_builtin_with_optional_argument</code> <code>is_perl_builtin_with_zero_and_or_one_arguments</code> <code>is_script</code>, <code>is_subroutine_name</code>, <code>is_unchecked_call</code> <code>is_valid_numeric_verbosity</code></p>

<p>See also <a href="../../Perl/Critic/Utils/PPI.html" class="podlinkpod"
>Perl::Critic::Utils::PPI</a>.</p>

<dt><a name=":data_conversion"
><code>:data_conversion</code></a></dt>

<dd>
<p>Generic manipulation, not having anything specific to do with Perl::Critic.</p>

<p>Includes: <code>hashify</code>, <code>words_from_string</code>, <code>interpolate</code></p>

<dt><a name=":ppi"
><code>:ppi</code></a></dt>

<dd>
<p>Things for dealing with <a href="../../PPI.html" class="podlinkpod"
>PPI</a>, other than classification.</p>

<p>Includes: <code>first_arg</code>, <code>parse_arg_list</code></p>

<p>See also <a href="../../Perl/Critic/Utils/PPI.html" class="podlinkpod"
>Perl::Critic::Utils::PPI</a>.</p>

<dt><a name=":internal_lookup"
><code>:internal_lookup</code></a></dt>

<dd>
<p>Translations between internal representations.</p>

<p>Includes: <code>severity_to_number</code>, <code>verbosity_to_format</code></p>

<dt><a name=":language"
><code>:language</code></a></dt>

<dd>
<p>Information about Perl not programmatically available elsewhere.</p>

<p>Includes: <code>precedence_of</code></p>

<dt><a name=":deprecated"
><code>:deprecated</code></a></dt>

<dd>
<p>Not surprisingly, things that are deprecated. It is preferred to use this tag to get to these functions, rather than the function names themselves, so as to mark any module using them as needing cleanup.</p>

<p>Includes: <code>find_keywords</code></p>
</dd>
</dl>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="SEE_ALSO"
>SEE ALSO</a></h1>

<p><a href="../../Perl/Critic/Utils/Constants.html" class="podlinkpod"
>Perl::Critic::Utils::Constants</a>, <a href="../../Perl/Critic/Utils/McCabe.html" class="podlinkpod"
>Perl::Critic::Utils::McCabe</a>, <a href="../../Perl/Critic/Utils/PPI.html" class="podlinkpod"
>Perl::Critic::Utils::PPI</a>,</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="AUTHOR"
>AUTHOR</a></h1>

<p>Jeffrey Ryan Thalhammer &#60;jeff@imaginative-software.com&#62;</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="COPYRIGHT"
>COPYRIGHT</a></h1>

<p>Copyright (c) 2005-2011 Imaginative Software Systems. All rights reserved.</p>

<p>This program is free software; you can redistribute it and/or modify it under the same terms as Perl itself. The full text of this license can be found in the LICENSE file included with this module.</p>
<p class="backlinkbottom"><b><a name="___bottom" href="../../index.html" title="All Documents">&lt;&lt;</a></b></p>

<!-- end doc -->

</body></html>
