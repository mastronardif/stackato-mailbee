<html><head><title>Perl::Critic::Utils::PPI</title>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1" >
<link rel="stylesheet" title="blkbluw" type="text/css" href="../../../_blkbluw.css" media="all" >
<link rel="alternate stylesheet" title="blkmagw" type="text/css" href="../../../_blkmagw.css" media="all" >
<link rel="alternate stylesheet" title="blkcynw" type="text/css" href="../../../_blkcynw.css" media="all" >
<link rel="alternate stylesheet" title="whtprpk" type="text/css" href="../../../_whtprpk.css" media="all" >
<link rel="alternate stylesheet" title="whtnavk" type="text/css" href="../../../_whtnavk.css" media="all" >
<link rel="alternate stylesheet" title="grygrnk" type="text/css" href="../../../_grygrnk.css" media="all" >
<link rel="alternate stylesheet" title="whtgrng" type="text/css" href="../../../_whtgrng.css" media="all" >
<link rel="alternate stylesheet" title="blkgrng" type="text/css" href="../../../_blkgrng.css" media="all" >
<link rel="alternate stylesheet" title="grygrnw" type="text/css" href="../../../_grygrnw.css" media="all" >
<link rel="alternate stylesheet" title="blkbluw" type="text/css" href="../../../_blkbluw.css" media="all" >
<link rel="alternate stylesheet" title="whtpurk" type="text/css" href="../../../_whtpurk.css" media="all" >
<link rel="alternate stylesheet" title="whtgrng" type="text/css" href="../../../_whtgrng.css" media="all" >
<link rel="alternate stylesheet" title="grygrnw" type="text/css" href="../../../_grygrnw.css" media="all" >

<script type="text/javascript" src="../../../_podly.js"></script>

</head>
<body class='pod'>
<!--
  generated by Pod::Simple::HTML v3.16,
  using Pod::Simple::PullParser v3.16,
  under Perl v5.012001 at Wed Apr 13 00:04:30 2011 GMT.

 If you want to change this HTML document, you probably shouldn't do that
   by changing it directly.  Instead, see about changing the calling options
   to Pod::Simple::HTML, and/or subclassing Pod::Simple::HTML,
   then reconverting this document from the Pod source.
   When in doubt, email the author of Pod::Simple::HTML for advice.
   See 'perldoc Pod::Simple::HTML' for more info.

-->

<!-- start doc -->
<p class="backlinktop"><b><a name="___top" href="../../../index.html" accesskey="1" title="All Documents">&lt;&lt;</a></b></p>

<div class='indexgroup'>
<ul   class='indexList indexList1'>
  <li class='indexItem indexItem1'><a href='#NAME'>NAME</a>
  <li class='indexItem indexItem1'><a href='#DESCRIPTION'>DESCRIPTION</a>
  <li class='indexItem indexItem1'><a href='#INTERFACE_SUPPORT'>INTERFACE SUPPORT</a>
  <li class='indexItem indexItem1'><a href='#IMPORTABLE_SUBS'>IMPORTABLE SUBS</a>
  <li class='indexItem indexItem1'><a href='#AUTHOR'>AUTHOR</a>
  <li class='indexItem indexItem1'><a href='#COPYRIGHT'>COPYRIGHT</a>
</ul>
</div>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="NAME"
>NAME</a></h1>

<p>Perl::Critic::Utils::PPI - Utility functions for dealing with PPI objects.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="DESCRIPTION"
>DESCRIPTION</a></h1>

<p>Provides classification of <a href="../../../PPI/Elements.html" class="podlinkpod"
>PPI::Elements</a>.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="INTERFACE_SUPPORT"
>INTERFACE SUPPORT</a></h1>

<p>This is considered to be a public module.
Any changes to its interface will go through a deprecation cycle.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="IMPORTABLE_SUBS"
>IMPORTABLE SUBS</a></h1>

<dl>
<dt><a name="is_ppi_expression_or_generic_statement(_$element_)"
><code>is_ppi_expression_or_generic_statement( $element )</code></a></dt>

<dd>
<p>Answers whether the parameter is an expression or an undifferentiated statement.
I.e.
the parameter either is a <a href="../../../PPI/Statement/Expression.html" class="podlinkpod"
>PPI::Statement::Expression</a> or the class of the parameter is <a href="../../../PPI/Statement.html" class="podlinkpod"
>PPI::Statement</a> and not one of its subclasses other than <code>Expression</code>.</p>

<dt><a name="is_ppi_generic_statement(_$element_)"
><code>is_ppi_generic_statement( $element )</code></a></dt>

<dd>
<p>Answers whether the parameter is an undifferentiated statement,
i.e.
the parameter is a <a href="../../../PPI/Statement.html" class="podlinkpod"
>PPI::Statement</a> but not one of its subclasses.</p>

<dt><a name="is_ppi_statement_subclass(_$element_)"
><code>is_ppi_statement_subclass( $element )</code></a></dt>

<dd>
<p>Answers whether the parameter is a specialized statement,
i.e.
the parameter is a <a href="../../../PPI/Statement.html" class="podlinkpod"
>PPI::Statement</a> but the class of the parameter is not <a href="../../../PPI/Statement.html" class="podlinkpod"
>PPI::Statement</a>.</p>

<dt><a name="is_ppi_simple_statement(_$element_)"
><code>is_ppi_simple_statement( $element )</code></a></dt>

<dd>
<p>Answers whether the parameter represents a simple statement,
i.e.
whether the parameter is a <a href="../../../PPI/Statement.html" class="podlinkpod"
>PPI::Statement</a>,
<a href="../../../PPI/Statement/Break.html" class="podlinkpod"
>PPI::Statement::Break</a>,
<a href="../../../PPI/Statement/Include.html" class="podlinkpod"
>PPI::Statement::Include</a>,
<a href="../../../PPI/Statement/Null.html" class="podlinkpod"
>PPI::Statement::Null</a>,
<a href="../../../PPI/Statement/Package.html" class="podlinkpod"
>PPI::Statement::Package</a>,
or <a href="../../../PPI/Statement/Variable.html" class="podlinkpod"
>PPI::Statement::Variable</a>.</p>

<dt><a name="is_ppi_constant_element(_$element_)"
><code>is_ppi_constant_element( $element )</code></a></dt>

<dd>
<p>Answers whether the parameter represents a constant value,
i.e.
whether the parameter is a <a href="../../../PPI/Token/Number.html" class="podlinkpod"
>PPI::Token::Number</a>,
<a href="../../../PPI/Token/Quote/Literal.html" class="podlinkpod"
>PPI::Token::Quote::Literal</a>,
<a href="../../../PPI/Token/Quote/Single.html" class="podlinkpod"
>PPI::Token::Quote::Single</a>,
or <a href="../../../PPI/Token/QuoteLike/Words.html" class="podlinkpod"
>PPI::Token::QuoteLike::Words</a>,
or is a <a href="../../../PPI/Token/Quote/Double.html" class="podlinkpod"
>PPI::Token::Quote::Double</a> or <a href="../../../PPI/Token/Quote/Interpolate.html" class="podlinkpod"
>PPI::Token::Quote::Interpolate</a> which does not in fact contain any interpolated variables.</p>

<p>This subroutine does <b>not</b> interpret any form of here document as a constant value,
and may not until <a href="../../../PPI/Token/HereDoc.html" class="podlinkpod"
>PPI::Token::HereDoc</a> acquires the relevant portions of the <a href="../../../PPI/Token/Quote.html" class="podlinkpod"
>PPI::Token::Quote</a> interface.</p>

<p>This subroutine also does <b>not</b> interpret entities created by the <a href="../../../Readonly.html" class="podlinkpod"
>Readonly</a> module or the <a href="../../../constant.html" class="podlinkpod"
>constant</a> pragma as constants,
because the infrastructure to detect these appears not to be present,
and the author of this subroutine (<b>not</b> Mr.
Shank or Mr.
Thalhammer) lacks the knowledge/expertise/gumption to put it in place.</p>

<dt><a name="is_subroutine_declaration(_$element_)"
><code>is_subroutine_declaration( $element )</code></a></dt>

<dd>
<p>Is the parameter a subroutine declaration,
named or not?</p>

<dt><a name="is_in_subroutine(_$element_)"
><code>is_in_subroutine( $element )</code></a></dt>

<dd>
<p>Is the parameter a subroutine or inside one?</p>

<dt><a name="get_constant_name_element_from_declaring_statement($statement)"
><code>get_constant_name_element_from_declaring_statement($statement)</code></a></dt>

<dd>
<p><b>This subroutine is deprecated.</b> You should use <a href="../../../PPIx/Utilities/Statement.html#get_constant_name_elements_from_declaring_statement()" class="podlinkpod"
>&#34;get_constant_name_elements_from_declaring_statement()&#34; in PPIx::Utilities::Statement</a> instead.</p>

<p>Given a <a href="../../../PPI/Statement.html" class="podlinkpod"
>PPI::Statement</a>,
if the statement is a <code>use constant</code> or <a href="../../../Readonly.html" class="podlinkpod"
>Readonly</a> declaration statement,
return the name of the thing being defined.</p>

<p>Given</p>

<pre>    use constant 1.16 FOO =&#62; &#39;bar&#39;;</pre>

<p>this will return &#34;FOO&#34;. Similarly, given</p>

<pre>    Readonly::Hash my %FOO =&#62; ( bar =&#62; &#39;baz&#39; );</pre>

<p>this will return &#34;%FOO&#34;.</p>

<p><b>Caveat:</b> in the case where multiple constants are declared using the same <code>use constant</code> statement (e.g. <code>use constant { FOO =&#62; 1, BAR =&#62; 2 };</code>, this subroutine will return the declaring <a href="../../../PPI/Structure/Constructor.html" class="podlinkpod"
>PPI::Structure::Constructor</a>. In the case of <code>use constant 1.16 { FOO =&#62; 1, BAR =&#62; 2 };</code> it may return a <a href="../../../PPI/Structure/Block.html" class="podlinkpod"
>PPI::Structure::Block</a> instead of a <a href="../../../PPI/Structure/Constructor.html" class="podlinkpod"
>PPI::Structure::Constructor</a>, due to a parse error in <a href="../../../PPI.html" class="podlinkpod"
>PPI</a>.</p>

<dt><a name="get_next_element_in_same_simple_statement(_$element_)"
><code>get_next_element_in_same_simple_statement( $element )</code></a></dt>

<dd>
<p>Given a <code>PPI::Element|PPI::Element</code>, this subroutine returns the next element in the same simple statement as defined by is_ppi_simple_statement(). If no next element can be found, this subroutine simply returns.</p>

<p>If the $element is undefined or unblessed, we simply return.</p>

<p>If the $element satisfies <code>is_ppi_simple_statement()</code>, we return, <b>unless</b> it has a parent which is a <a href="../../../PPI/Structure/List.html" class="podlinkpod"
>PPI::Structure::List</a>.</p>

<p>If the $element is the last significant element in its <a href="../../../PPI/Node.html" class="podlinkpod"
>PPI::Node</a>, we replace it with its parent and iterate again.</p>

<p>Otherwise, we return <code>$element-&#62;snext_sibling()</code>.</p>

<dt><a name="get_previous_module_used_on_same_line(_$element_)"
><code>get_previous_module_used_on_same_line( $element )</code></a></dt>

<dd>
<p>Given a <a href="../../../PPI/Element.html" class="podlinkpod"
>PPI::Element</a>, returns the <a href="../../../PPI/Element.html" class="podlinkpod"
>PPI::Element</a> representing the name of the module included by the previous <code>use</code> or <code>require</code> on the same line as the $element. If none is found, simply returns.</p>

<p>For example, with the line</p>

<pre>    use version; our $VERSION = ...;</pre>

<p>given the <a href="../../../PPI/Token/Symbol.html" class="podlinkpod"
>PPI::Token::Symbol</a> instance for <code>$VERSION</code>, this will return &#34;version&#34;.</p>

<p>If the given element is in a <code>use</code> or &#60;require&#62;, the return is from the previous <code>use</code> or <code>require</code> on the line, if any.</p>
</dd>
</dl>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="AUTHOR"
>AUTHOR</a></h1>

<p>Elliot Shank &#60;perl@galumph.com&#62;</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="COPYRIGHT"
>COPYRIGHT</a></h1>

<p>Copyright (c) 2007-2011 Elliot Shank.</p>

<p>This program is free software; you can redistribute it and/or modify it under the same terms as Perl itself. The full text of this license can be found in the LICENSE file included with this module.</p>
<p class="backlinkbottom"><b><a name="___bottom" href="../../../index.html" title="All Documents">&lt;&lt;</a></b></p>

<!-- end doc -->

</body></html>
